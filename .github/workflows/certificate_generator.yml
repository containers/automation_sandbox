# .github/workflows/certificate_generator.yml
name: Generate Contributor Certificate Preview

# This action triggers automatically when a pull request is closed,
# or can be run manually from the Actions tab.
on:
  pull_request:
    types: [closed]
    branches:
      - main
  workflow_dispatch:
    inputs:
      contributor_username:
        description: 'The GitHub username of the contributor'
        required: true
      pr_number:
        description: 'The pull request number'
        required: true

# Permissions needed for this workflow.
permissions:
  contents: read
  pull-requests: write
  actions: read

jobs:
  screenshot_and_comment:
    # This job runs if the PR was merged or if it's a manual trigger.
    # The logic for first-time contributors is handled in a dedicated step below.
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.pull_request.merged == true }}
    runs-on: ubuntu-latest
    steps:
      # Step 1: Check if this is the contributor's first merged PR.
      # This step is the source of truth and will control the execution of subsequent steps.
      - name: Check for first merged PR
        id: check_first_pr
        if: ${{ github.event_name == 'pull_request' }}
        uses: actions/github-script@v7
        with:
          script: |
            const author = context.payload.pull_request.user.login;
            const query = `repo:${context.repo.owner}/${context.repo.repo} is:pr is:merged author:${author}`;
            
            console.log(`Searching for merged PRs from @${author} with query: "${query}"`);
            
            const result = await github.rest.search.issuesAndPullRequests({ q: query });
            const mergedPRs = result.data.total_count;

            if (mergedPRs === 1) {
              console.log(`SUCCESS: This is the first merged PR from @${author}. Proceeding...`);
              core.setOutput('is_first_pr', 'true');
            } else {
              console.log(`INFO: Skipping certificate generation. @${author} has ${mergedPRs} total merged PRs.`);
              core.setOutput('is_first_pr', 'false');
            }
      
      # Step 2: Checkout the repository containing the certificate HTML file.
      - name: Checkout containers/automation repository
        if: ${{ github.event_name == 'workflow_dispatch' || steps.check_first_pr.outputs.is_first_pr == 'true' }}
        uses: actions/checkout@v4
        with:
          repository: containers/automation
          path: automation-repo

      # Step 3: Update the HTML file locally
      - name: Update HTML file
        if: ${{ github.event_name == 'workflow_dispatch' || steps.check_first_pr.outputs.is_first_pr == 'true' }}
        run: |
          HTML_FILE="automation-repo/certificate-generator/certificate_generator.html"
          CONTRIBUTOR_NAME="${{ github.event.inputs.contributor_username || github.event.pull_request.user.login }}"
          PR_NUMBER="${{ github.event.inputs.pr_number || github.event.pull_request.number }}"
          MERGE_DATE=$(date -u +"%B %d, %Y")

          sed -i "/id=\"contributorName\"/s/value=\"[^\"]*\"/value=\"${CONTRIBUTOR_NAME}\"/" ${HTML_FILE} || { echo "ERROR: Failed to update contributor name."; exit 1; }
          sed -i "/id=\"prNumber\"/s/value=\"[^\"]*\"/value=\"#${PR_NUMBER}\"/" ${HTML_FILE} || { echo "ERROR: Failed to update PR number."; exit 1; }
          sed -i "/id=\"mergeDate\"/s/value=\"[^\"]*\"/value=\"${MERGE_DATE}\"/" ${HTML_FILE} || { echo "ERROR: Failed to update merge date."; exit 1; }

      # Step 4: Setup Node.js environment
      - name: Setup Node.js
        if: ${{ github.event_name == 'workflow_dispatch' || steps.check_first_pr.outputs.is_first_pr == 'true' }}
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      # Step 5: Install Puppeteer, embed-images, and ImageMagick
      - name: Install Puppeteer, embed-images, and ImageMagick
        if: ${{ github.event_name == 'workflow_dispatch' || steps.check_first_pr.outputs.is_first_pr == 'true' }}
        run: |
          # Install ImageMagick for image compression
          sudo apt-get update && sudo apt-get install -y imagemagick
          # Install npm packages
          npm install puppeteer embed-images || { echo "ERROR: Failed to install npm packages."; exit 1; }

      # Step 6: Take a screenshot of the certificate div
      - name: Create and run screenshot script
        if: ${{ github.event_name == 'workflow_dispatch' || steps.check_first_pr.outputs.is_first_pr == 'true' }}
        run: |
          cat <<'EOF' > screenshot.js
          const puppeteer = require('puppeteer');
          const path = require('path');
          (async () => {
            const browser = await puppeteer.launch({ args: ['--no-sandbox', '--disable-setuid-sandbox'] });
            const page = await browser.newPage();
            const htmlPath = 'file://' + path.resolve('automation-repo/certificate-generator/certificate_generator.html');
            await page.goto(htmlPath, { waitUntil: 'networkidle0' });
            await page.setViewport({ width: 1080, height: 720 });
            const element = await page.$('#certificatePreview');
            if (!element) {
              console.error('Could not find element #certificatePreview.');
              process.exit(1);
            }
            await element.screenshot({ path: 'certificate.png' });
            await browser.close();
            console.log('Screenshot saved as certificate.png');
          })().catch(err => {
            console.error(err);
            process.exit(1);
          });
          EOF
          node screenshot.js || { echo "ERROR: Screenshot script failed."; exit 1; }

      # Step 7: Create markdown file and embed image as base64
      - name: Create embedded image markdown
        if: ${{ github.event_name == 'workflow_dispatch' || steps.check_first_pr.outputs.is_first_pr == 'true' }}
        run: |
          # Check if certificate.png exists
          if [ ! -f "certificate.png" ]; then
            echo "ERROR: certificate.png not found!"
            exit 1
          fi
          
          # Show file info for debugging
          ls -la certificate.png
          
          # Create a simple markdown file with the image reference
          echo "![Certificate Preview](certificate.png)" > certificate_temp.md
          
          # Use embed-images to convert the image to base64 and embed it
          npx embed-images certificate_temp.md -o certificate_embedded.md
          
          # Debug: Show the result
          echo "=== Original markdown ==="
          cat certificate_temp.md
          echo "=== Embedded markdown ==="
          cat certificate_embedded.md
          echo "========================="
          
          # Check if embed-images worked (should contain base64 data)
          if grep -q "data:image" certificate_embedded.md; then
            echo "SUCCESS: embed-images worked correctly"
            cp certificate_embedded.md embedded_image_final.md
          else
            echo "WARNING: embed-images didn't work, falling back to manual base64 conversion"
            
            # Check if the image is too large for GitHub comments
            IMAGE_SIZE=$(stat -c%s certificate.png)
            echo "Original image size: ${IMAGE_SIZE} bytes"
            
            if [ "$IMAGE_SIZE" -gt 50000 ]; then
              echo "Image is large, trying aggressive compression..."
              # More aggressive compression for GitHub compatibility
              if command -v convert >/dev/null 2>&1; then
                # Try multiple compression strategies
                convert certificate.png -quality 60 -resize "600x400>" -strip certificate_compressed.png
                if [ -f certificate_compressed.png ]; then
                  COMPRESSED_SIZE=$(stat -c%s certificate_compressed.png)
                  echo "Compressed image size: ${COMPRESSED_SIZE} bytes"
                  
                  # If still too large, try JPEG conversion which is more efficient
                  if [ "$COMPRESSED_SIZE" -gt 50000 ]; then
                    echo "Still large, converting to JPEG..."
                    convert certificate.png -quality 85 -resize "600x400>" -strip certificate_compressed.jpg
                    if [ -f certificate_compressed.jpg ]; then
                      JPG_SIZE=$(stat -c%s certificate_compressed.jpg)
                      echo "JPEG size: ${JPG_SIZE} bytes"
                      if [ "$JPG_SIZE" -lt "$COMPRESSED_SIZE" ]; then
                        IMAGE_FILE="certificate_compressed.jpg"
                        IMAGE_TYPE="jpeg"
                      else
                        IMAGE_FILE="certificate_compressed.png"
                        IMAGE_TYPE="png"
                      fi
                    else
                      IMAGE_FILE="certificate_compressed.png"
                      IMAGE_TYPE="png"
                    fi
                  else
                    IMAGE_FILE="certificate_compressed.png"
                    IMAGE_TYPE="png"
                  fi
                else
                  echo "Compression failed, using original"
                  IMAGE_FILE="certificate.png"
                  IMAGE_TYPE="png"
                fi
              else
                echo "ImageMagick not available, using original image"
                IMAGE_FILE="certificate.png"
                IMAGE_TYPE="png"
              fi
            else
              IMAGE_FILE="certificate.png"
              IMAGE_TYPE="png"
            fi
            
            # Check final size before embedding
            FINAL_SIZE=$(stat -c%s "$IMAGE_FILE")
            echo "Final image size: ${FINAL_SIZE} bytes"
            
            if [ "$FINAL_SIZE" -gt 80000 ]; then
              echo "Image still too large for reliable GitHub embedding, will upload as artifact instead"
              echo "UPLOAD_ARTIFACT=true" >> $GITHUB_ENV
              echo "ðŸ“œ **Certificate Preview Generated**" > embedded_image_final.md
              echo "" >> embedded_image_final.md
              echo "_The certificate image was generated but is too large to embed directly. You can download it from the [workflow run artifacts](\${{ github.server_url }}/\${{ github.repository }}/actions/runs/\${{ github.run_id }})._" >> embedded_image_final.md
            else
              # Manual fallback: create base64 embedded image with HTML img tag for better compatibility
              BASE64_DATA=$(base64 -w 0 "$IMAGE_FILE")
              echo "<img src=\"data:image/${IMAGE_TYPE};base64,${BASE64_DATA}\" alt=\"Certificate Preview\" style=\"max-width: 100%; height: auto;\" />" > embedded_image_final.md
            fi
          fi
          
          # Debug: Show file size and first 200 characters of the final embedded image
          echo "=== Final embedded image file size ==="
          ls -la embedded_image_final.md
          echo "=== Final embedded image (first 200 chars) ==="
          head -c 200 embedded_image_final.md
          echo ""
          echo "=== Final embedded image (last 100 chars) ==="
          tail -c 100 embedded_image_final.md
          echo ""
          echo "========================="
          
          # Store just a flag to indicate we have the embedded image ready
          echo "EMBEDDED_IMAGE_READY=true" >> $GITHUB_ENV

      # Step 7.5: Upload artifact if image is too large to embed
      - name: Upload certificate as artifact (fallback for large images)
        if: ${{ env.UPLOAD_ARTIFACT == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: certificate-preview
          path: certificate.png
          retention-days: 7

      # Step 8: Comment on Pull Request with embedded image
      - name: Comment with embedded certificate image
        if: ${{ github.event_name == 'workflow_dispatch' || steps.check_first_pr.outputs.is_first_pr == 'true' }}
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            try {
              // Read the embedded image from file instead of environment variable
              const embeddedImage = fs.readFileSync('embedded_image_final.md', 'utf8');
              
              // Debug: Log image info
              console.log(`Embedded image length: ${embeddedImage.length}`);
              console.log(`Embedded image starts with: ${embeddedImage.substring(0, 100)}`);
              console.log(`Embedded image ends with: ${embeddedImage.substring(embeddedImage.length - 50)}`);
              
              let body;
              
              if (context.eventName === 'workflow_dispatch') {
                // Manual trigger case
                const contributorName = '${{ github.event.inputs.contributor_username }}';
                const prNumber = '${{ github.event.inputs.pr_number }}';
                body = `ðŸ“œ Certificate preview generated for @${contributorName} (PR #${prNumber}):\n\n${embeddedImage}`;
              } else {
                // Auto trigger case for first-time contributors
                const username = '${{ github.event.pull_request.user.login }}';
                body = `ðŸŽ‰ Congratulations on your first merged pull request, @${username}! Thank you for your contribution.\n\nHere's a preview of your certificate:\n\n${embeddedImage}`;
              }
              
              const issueNumber = context.eventName === 'workflow_dispatch' ? 
                parseInt('${{ github.event.inputs.pr_number }}') : 
                context.issue.number;
              
              await github.rest.issues.createComment({
                issue_number: issueNumber,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: body,
              });
            } catch (error) {
              core.setFailed(`ERROR: Failed to comment on PR. Details: ${error.message}`);
            }
      
      # Step 9: Clean up temporary files
      - name: Clean up temporary files
        if: ${{ always() && (github.event_name == 'workflow_dispatch' || steps.check_first_pr.outputs.is_first_pr == 'true') }}
        run: |
          rm -f certificate.png certificate_compressed.png certificate_compressed.jpg certificate_temp.md certificate_embedded.md embedded_image_final.md
